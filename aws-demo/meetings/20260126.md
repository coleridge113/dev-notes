# Question
>can you estimate how many position "emissions" (ie calls to BatchUpdateDevicePosition) a device will generate? It may be worth checking the device's default behavior (ie whether it sends updates every 10 seconds)
>
>For example, if its currently emitting every 10 seconds, you can assume a rider will be on the road max 2 hours. Every 10 seconds means: 
>2 x 60 (mins per hour) x 60 (seconds per minute) = 7200 seconds
>7200 / 10 seconds = 720 times
>
>Can that update frequency be changed?
>
>This will help us estimate how many geofence evaluations we will run per month



RS (MQTT) -> AWS IOT Core -> IOT Rule



# FACTS
## Device default behavior
The GPS provider used in the current demo has options to reduce update frequency.
Currently, it's configured to send 1 location update per second

```
    private val request = LocationRequest.Builder(
            Priority.HIGH_ACCURACY,    // can be changed to prioritize battery life but leads to less updates
            30_000L      // update frequency; can be changed to 30_000L (30 seconds)
        ).build()

Priority enum:
HIGH_ACCURACY = street level accuracy
BALANCED = block level accuracy
BATTERY_SAVER = city level accuracy
```

> [!NOTE] What saves the battery is the Priority level; not the update frequency

> [!NOTE] Radar.io uses a 30-second interval for their highest update frequency setting

## IoT Core with RS

1. RS programatically creates the MQTT client with JWT authentication
2. The MQTT client within RS publishes location data to the selected topic
3. IOT Core catches this message using a configured Rule
4. The Rule triggers an action that sends to AWS Location Services

The important part here is building the MQTT client in the device.
The client requires some form of authorization.
I was able to work with X.509 certificates (see sample code below); however, this is not viable for a fleet of devices.
AWS does allow for custom, token-based authorization which is what RS currently does.
*^Yet to try this method.*

> [!NOTE] Sample code to build MQTT client in RS
```
    private fun initMqttClientWithX509(clientEndpoint: String, certificateData: String, keyData: String, rootCA: String) {
        if (clientEndpoint == null || certificateData == null || keyData == null || rootCA == null) {
            Log.e("IotManager", "Missing required credential files in assets!")
            return
        }

        val builder = AwsIotMqtt5ClientBuilder.newDirectMqttBuilderWithMtlsFromMemory(clientEndpoint, certificateData, keyData)
            .withCertificateAuthority(rootCA)
            .withClientId("Rider-1")    // identification to resume a session if it disconnects 
            .withSessionExpiryIntervalSeconds(3600L)        // 
            .withSessionBehavior(Mqtt5ClientOptions.ClientSessionBehavior.REJOIN_ALWAYS)
            .withKeepAliveIntervalSeconds(60L)  // prevents idling that might lead to a disconnection
            .withLifeCycleEvents(MqttLifeCycleEvents())

        val client: Mqtt5Client = builder.build()
        client.start()
    }
```


## Not all location updates are accepted
The Tracker Resource filters out non-significant updates based on the selected option. This is done mainly to save costs on Geofence evaluations:

**Filtering Options (Choose 1)**
- Location-based:
    If an update is 30 meters from the last position update, it will be accepted.
    Any update received before the 30-meter mark is discarded

- Time-based:
    If an update is 30 seconds from the last position update, it will be accepted.
    Any update received before the 30-second mark is discarded

- Accuracy-based:
    If an update is greater than the combined accuracy of the last two updates, it will be accepted.
    Any update received outside of that logic is discarded



# References
- [AWS Tracker Filtering](https://aws.amazon.com/blogs/mobile/amazon-location-service-enables-position-filtering-to-reduce-position-jitter-and-cost-of-tracking/)
- [Radar.io Update Frequency](https://docs.radar.com/sdk/tracking)


